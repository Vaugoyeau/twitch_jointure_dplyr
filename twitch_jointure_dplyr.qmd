---
title: "Jointure de tables avec `{dplyr}`"
author: "Marie Vaugoyeau"
date: "2024/06/25"
date-format: "D MMMM YYYY"
format: 
  pdf:
    toc: true
    number-sections: true
    papersize: letter
execute: 
  warning: false
---

# Les données  
## Import des packages  
```{r}
library(tidyverse)
```

## Température quotidienne  
Les données sont [les températures quotidiennes départementales](https://www.data.gouv.fr/fr/datasets/temperature-quotidienne-departementale-depuis-janvier-2018/) 

```{r}

```


## Densité de population par départements  
ainsi que les [données de densités par départements](https://www.insee.fr/fr/statistiques/6683035?sommaire=6683037).  
```{r}


```


# Concaténation de tables  
## Pourquoi ?  
Pour coupler des informations présentes dans différentes tables pour explorer le lien, par exemple les variations de températures en fonction de la densité de population.  
  
## Problème  
Pour que les jointures se passent bien, il faut que les informations présentes dans une table correspondent à celles présente dans l'autre !  
  
## Différents types de jointures  
Prenons deux tables :   
```{r}

```
  
On veut avoir les informations `r letters[23:26]` pour tous les individus -> jointure totale avec `full_join()` de `{dplyr}`  
  
```{r}

```

On veut que les lignes des individus présents dans les deux tableaux -> jointure interne avec `inner_join()` de `{dplyr}`  
```{r}

```

On veut toutes les caractéristiques disponibles pour les individus d'une des deux tables -> jointure à gauche ou à droite avec `left_join()` et `right_join()` de `{dplyr}`. Le sens de la jointure a une influence dans l'ordre des tables mais fait la même chose si on inverse l'ordre  
```{r}

```

On veut les individus qui ne sont pas présent dans l'autre table -> anti-jointure avec `anti_join()` de `{dplyr}`. L'ordre à son importance, ce sont les individus de la première table qui ne sont pas présent dans la deuxième qui sortent.  
```{r}

```


# Préparation des données en amont 
## Identification de la clé de jointure  
Si pas défaut les fonctions prennent comme clé de jointure les colonnes qui ont le même nom, ce n'est pas nécessairement ce que l'on veut obtenir.  
La clé peut être basé sur une ou plusieurs colonnes.  
  
```{r}


```

Ici : `DEP` == `departement`    
  
## Même type d'objets  
Les données doivent-être de même type donc vérification de la classe des clés est indispensable.  
```{r}

```
  
## Présence de doublons  
```{r}



```


## Présence de valeurs manquantes  
```{r}

```

Ce n'est pas nécessairement un problème d'avoir des doublons ou des valeurs manquantes mais il faut que cela correspondent à ce que l'on souhaite faire.  
  
# Jointure total avec `full_join()` 
## Réalisation de différents types de jointure  
```{r}


```

## Vérification de la table crée  
Calcul de la taille attendue  
```{r}



```
  
Recherche des `NA`  
```{r}


```

Possibilité d'utiliser l'anti-jointure pour identifier les lignes à problème  
```{r}

```
  
# Jointure interne avec `inner_join()`  
## Création de la jointure la plus stricte  
```{r}

```
  
## Vérification de la jointure interne  
```{r}

```
  

